1. 数组
    + 提到数组，并且有苛刻条件，比如说控制空间复杂度，可以考虑**排序操作**；
    + 给定正数且不重复数组nums，考虑方法nums的元素值与新数组的下标相对应的方法。即numsIndex[nums[i]] = i;即把nums的值当作numsIndex的索引，即numsIndex中nums元素越大越靠后。（448）
    + 需要map<Integer, E>一类的数据结构时，如果已知key的数量时有限的，可以构造长度为该数量的数组以节约空间，数组的索引即为key（299, 387, 781, 1128），大幅提升效率！

1. 二叉树
    + **中序遍历**二叉搜索树得到的是递增序列
    + 遍历的方法：迭代和递归
    + 深度优先遍历（104, 110二叉树的深度）
    + **递归**:**宏观的**去认识这个递归是完成什么功能，关注其结果即可，再对结果进行操作！（常常配合后序遍历无脑递归114, 222, 508, 897, 654）

1. 链表
    + **快慢双指针**（fast=2n, slow = n; fast = 1+n, slow = n)
    + **递归**：交换链表节点（24），反转链表（递归理解：https://lyl0724.github.io/2020/01/25/1/）
    + **尾插法**：（86）
    + **头插法**
    + 想象，改指针而不动元素（翻转链表）
    + 链表拆分+合并

1. 二分法
    + 题目：有序序列+时间复杂度o(logn)，应考虑二分法（300）
    + java源码中的二分法的判断条件和返回值要注意
    + 时刻注意：二分条件（left<=right）或者（left<right）的等号是否需要
        + 中间返回mid时，一般需要有等号
        + 末尾返回left的时候，一般可以不加等号
    + 中间值mid的写法
        + (left+right)/2 (初级写法，有相加溢出的风险)
        + left + (right - left)/2 （中级写法，一定程度上避免了相加的大数溢出，但是当left为很小的负数，也有溢出的可能）
        + (left+right)>>>1 （高级写法，源于java源码binarySearch的写法[总结](https://leetcode-cn.com/problems/guess-number-higher-or-lower/solution/shi-fen-hao-yong-de-er-fen-cha-zhao-fa-mo-ban-pyth/)）
    + 找到target但是不返回索引，而是一直迭代，直到剩一个元素(34，300)
    + 时刻防止溢出，乘法用除法代替，不行就用long类型(367，441)
    + 前面一堆０，后面一堆１，然后寻找第一个１的二分问题(153)

1. 回溯
    + 首先根据题意画出**递归树**，再根据递归树写代码；其实难点在于画出递归树，画出来以后讨论接近！
    + 关键因素：外层循环（有时也没有）+内层的backtrack方法：
        + backtrack方法每次的起始点，即外层循环给的值
    + 本质就是深度遍历，但是在backtrack方法中加上了往下一层传递的参数（129）
    + backtrack 方法传参不要用 n++ 或者 ++n， 而是n+1
    + 记忆化搜索：120, 322,343。增加memo数组，保存重复出现的递归操作结果
    + 用回溯但是不求具体结果只求数量，用高级回溯方法（1079）

1. 动态规划
    + 只要求最优值，而不需所有最优解，可以考虑动态规划，否则回溯
    + 空间优化，需要保存几个原来的最优解以获得新的解，就只开辟相应的空间（120）
    + 关键在于1.定义状态， 2.状态转化关系， 3.矩阵求解（股票买卖的几道题）

1. 贪心
    + 贪心的效率比动态规划更高，但是需要找到并证明贪心法则的正确性

1. 滑动窗口
    + 将o(n2)简化到o(n),209

1. 位运算（136,137,260）
    + x/2 = x>>1, x%2 = x & 1，x%(2^N) = x&(2^N-1)
    + a^b^c = a^c^b, a^a=0, 0^a=a
    + x & ~x = 0,x & ~0 =x（137）
    + >>：带符号右移。正数右移高位补0，负数右移高位补1。
    + >>>：无符号右移。无论是正数还是负数，高位通通补0。
    + 对于正数而言，>>和>>>没区别。负数区别很大！[Java中带符号右移和无符号右移的区别](https://blog.csdn.net/zerolaw/article/details/81081823)

1. 数据结构
    + 优先队列PriorityQueue解决top K问题（347）
    + java的Map.Entry，解决java没有pair的数据结构问题（365）
    + 逆序处理要想到使用栈（445）

1. 卡int边界值时，不妨把int用Integer代替，不用设Interger.MAX_VALUE，直接赋初始值为null


1. 其他
    + Java中，str.split函数切字符串的时候，为了防止切出空字符串，先对字符串trim操作，去除头尾的空格。匹配多个空格要贪婪匹配“\\s+”(819)
    + 需要公共操作的int不要作为形参传递，而是作为类变量
    + 连续的StringBuilder.inser(0,"str")可以改写为sb.append,最后再一次reverse()(43)
    + Arrays.sort(arr, lambda)的运用（56, 1353）
    ```
    Arrays.sort(events, (e1, e2)-> {
            if(e1[1]==e2[1]){
                return e1[0]-e2[0];
            } else {
                return e1[1]-e2[1];
            }
        });

    Arrays.sort(events, (e1, e2)-> {return e1[1]==e2[1]?e1[0]-e2[0]:e1[1]-e2[1];});

    Arrays.sort(events, (e1, e2)-> e1[1]==e2[1]?e1[0]-e2[0]:e1[1]-e2[1]);
    ```
    + 回文子串的思路：中心为轴，两边扩展。长度为n的字符串中可能的中心点有2n-1个

